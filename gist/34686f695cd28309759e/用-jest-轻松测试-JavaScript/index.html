<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Jichao Ouyang's Blogist</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="username" content="">
		<meta name="description" content="<img src=https://travis-ci.org/jcouyang/blogist.svg> or failed">
    <link rel="stylesheet" href="/bower_components/bootswatch/flatly/bootstrap.min.css" media="screen">

		<link rel="stylesheet" href="https://gist.github.com/assets/embed-91ddfaf352483e316b5398263e92b3e0.css" media="screen">
		<link rel="stylesheet" href="/stylesheets/blogist.css" media="screen">
		<script>
			if(window.location.pathname!="/"){
	window.location = window.location.origin + "#" +window.location.pathname.replace(".html","");
			}
			</script>
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
				<script src="/bower_components/bootswatch/bower_components/html5shiv/dist/html5shiv.js"></script>
				<script src="/bower_components/bootswatch/bower_components/respond/dest/respond.min.js"></script>
				<![endif]-->
		
  </head>
  <body>
		<div class="container">

			<div class="row">
				<div class="sidebar col-md-2">
				</div>

				<div class="col-md-8">

					<div class="article">
						<div id="gist13968076" class="gist">
        <div class="gist-file">
          <div class="gist-data gist-syntax">
            

    <div class="readme context-loader-container context-loader-overlay">
      <article class="markdown-body js-file "
        data-task-list-update-url="https://gist.github.com/jcouyang/34686f695cd28309759e/file/3-reason-to-use-jest-to-test-your-javascript.md">
        <ul class="task-list">
<li><a href="https://rawgit.com/jcouyang/cc0e65e36af9c7c001e2/raw/b100f45ebfe7c196043cb10f967123f9ebde7ffc/1-painless-javascript-testing.html#/28" rel="noreferrer">slides</a></li>
<li><a href="https://github.com/jcouyang/jest-sample" rel="noreferrer">source</a></li>
</ul>

<p>Javascript 的测试, 不管在用 <a href="http://jasmine.github.io" rel="noreferrer">jasmine</a> 还是 <a href="http://visionmedia.github.io/mocha/" rel="noreferrer">mocha</a>,
都是很头疼的事情. 但是自从有了 <a href="http://facebook.github.io/jest/" rel="noreferrer">jest</a>, 一口气写7个测试, 腰也不疼了, 头也不疼了.</p>

<p>只需要 3 个理由</p>

<p>在说用 jest 测为什么好之前,我们先来看我们要测的一个例子.</p>

<h2>
<a name="user-content-" class="anchor" href="#" rel="noreferrer"><span class="octicon octicon-link"></span></a>🌰</h2>

<p>比如我要写一个模块要去取github 用户的follower 和他所有 repo 的 follower 数量.</p>

<p>那么我们应该有一个 User 的 Model.</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// user.js</span>
<span class="pl-s">var</span> $ <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>jquery<span class="pl-pds">'</span></span>);
<span class="pl-st">function</span> <span class="pl-en">User</span>(<span class="pl-vpf">name</span>) {
  <span class="pl-v">this</span>.<span class="pl-sc">name</span> <span class="pl-k">=</span> name;
  <span class="pl-v">this</span>.followers <span class="pl-k">=</span> <span class="pl-c1">0</span>;
}
<span class="pl-s3">User</span>.<span class="pl-sc">prototype</span>.<span class="pl-en">fetch</span> <span class="pl-k">=</span> <span class="pl-st">function</span>(){
  <span class="pl-k">return</span> $.ajax({
    url<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>https://api.github.com/users/<span class="pl-pds">'</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-sc">name</span>,
    method<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>get<span class="pl-pds">'</span></span>,
    dataType<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>json<span class="pl-pds">'</span></span>
  }).then(<span class="pl-st">function</span>(<span class="pl-vpf">data</span>){
      <span class="pl-v">this</span>.followers <span class="pl-k">=</span> data.followers;
  }.bind(<span class="pl-v">this</span>));
};
<span class="pl-sv">module</span>.exports <span class="pl-k">=</span> User;</pre></div>

<p>我们还需要一个 repo 的 model, 大同小异略去</p>

<p>最后, 整合这俩我要的东西, 并显示在页面上</p>

<div class="highlight highlight-js"><pre><span class="pl-c">// follower.js</span>
<span class="pl-s">var</span> $ <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>jquery<span class="pl-pds">'</span></span>);
<span class="pl-st">function</span> <span class="pl-en">followerOf</span>(<span class="pl-vpf">user</span>, <span class="pl-vpf">repo</span>) {
  user.fetch().then(repo.fetch).then(<span class="pl-st">function</span>(<span class="pl-vpf">_</span>){
    $(<span class="pl-s1"><span class="pl-pds">'</span>#content<span class="pl-pds">'</span></span>).<span class="pl-sc">text</span>(user.<span class="pl-sc">name</span> <span class="pl-k">+</span><span class="pl-s1"><span class="pl-pds">"</span>'s followers: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> user.followers <span class="pl-k">+</span>
                       <span class="pl-s1"><span class="pl-pds">"</span> and his repo <span class="pl-pds">"</span></span><span class="pl-k">+</span> repo.<span class="pl-sc">name</span> <span class="pl-k">+</span><span class="pl-s1"><span class="pl-pds">"</span>'s followers:<span class="pl-pds">"</span></span> <span class="pl-k">+</span> repo.followers);
    });
};

<span class="pl-sv">module</span>.exports <span class="pl-k">=</span> followerOf;</pre></div>

<h2></h2>

<h2>
<a name="user-content-1-auto-mock" class="anchor" href="#1-auto-mock" rel="noreferrer"><span class="octicon octicon-link"></span></a>1. Auto Mock</h2>

<p>自动 mock 实在是最大的亮点, jest 重写了 require, 所以你的代码里的所有 require 来的东西都自动 mock.</p>

<p>因为在你的测试中往往只关心一个模块, 对于他的所有依赖其实都是无所谓的.</p>

<p>在例子中, 如果我们在测 repo.js 的时候完全不关心那两个 jquery 的 ajax 方法到底
写对没写对,反正我们期望能从 ajax 里面拿到我们想要的东西就对了. 因此, 我希望 jquery 的
所有方法都是 mock 的. jest 让你很轻松的做到这点, 因为是自动mock所有require 的东西, 而
对于目标测试模块, 只需要说我<code>dontMock</code> 我的目标模块就好了.</p>

<div class="highlight highlight-js"><pre>jest.dontMock(<span class="pl-s1"><span class="pl-pds">'</span>../repo<span class="pl-pds">'</span></span>);
describe(<span class="pl-s1"><span class="pl-pds">'</span>Repo Model<span class="pl-pds">'</span></span>, <span class="pl-st">function</span>(){
  <span class="pl-s">var</span> repo;
  beforeEach(<span class="pl-st">function</span>(){
        <span class="pl-s">var</span> $ <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>jquery<span class="pl-pds">'</span></span>).setAjaxReturn({stargazers_count<span class="pl-k">:</span> <span class="pl-c1">23</span>});
        <span class="pl-s">var</span> Repo <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>../repo<span class="pl-pds">'</span></span>);
    repo <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Repo</span>(<span class="pl-s1"><span class="pl-pds">'</span>jcouyang<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>gira<span class="pl-pds">'</span></span>);

    });

  it(<span class="pl-s1"><span class="pl-pds">'</span>should populate properties with data from github api<span class="pl-pds">'</span></span>, <span class="pl-st">function</span>(){
        repo.fetch();
        expect(repo.followers).toBe(<span class="pl-c1">23</span>);
  });
});
</pre></div>

<p>所以这个测试看起来就跟文档一样了,</p>

<ol class="task-list">
<li>
<code>dontMock('./repo')</code> 说明我关心<code>repo</code>
这个模块, 其他我都不 care.</li>
<li>before 是我要进行操作所需要的东西.

<ul class="task-list">
<li>我要 jquery ajax 请求给我想要的数据</li>
<li>我要一个我要测的 Repo 类的实例</li>
</ul>
</li>
<li>it 说明我关心地行为是神马

<ul class="task-list">
<li>我关心 fetch 的行为,是去取数据并给我把数据填充到我的 repo 实例中</li>
</ul>
</li>
</ol>

<blockquote>
<p>你可能要问 <code>segAjaxReturn</code> 是哪里冒出来的. 忍一忍稍后告诉你.</p>
</blockquote>

<p>有没有看虽然我显式的 mock jquery, 但是 Repo 里面 require 的 jquery 其实是假的, 不然我们就真的访问
github api 了. 那样就不会每次都返回 23 个 follower 了.</p>

<h2>
<a name="user-content-2-jsdom" class="anchor" href="#2-jsdom" rel="noreferrer"><span class="octicon octicon-link"></span></a>2. jsdom</h2>

<p>好了现在我们来测 follower.js, 先看 follower 到底干了什么, 拿到 user 和 repo
的信息然后组成一句话放到页面 id 为 content 的元素下面.</p>

<p>好, 所以我们关心</p>

<ul class="task-list">
<li>组出来的话对不对</li>
<li>有没有放到 content 元素下, 所以 jquery 的操作对不对也是我们关心的一部分</li>
</ul>

<p>我们不关心</p>

<ul class="task-list">
<li>user 干了什么</li>
<li>repo 干了什么</li>
</ul>

<p>这样,关心的就是不能 mock 的</p>

<div class="highlight highlight-js"><pre>jest.dontMock(<span class="pl-s1"><span class="pl-pds">'</span>../follower<span class="pl-pds">'</span></span>)
    .dontMock(<span class="pl-s1"><span class="pl-pds">'</span>jquery<span class="pl-pds">'</span></span>);
describe(<span class="pl-s1"><span class="pl-pds">'</span>follower<span class="pl-pds">'</span></span>, <span class="pl-st">function</span>(){
  <span class="pl-s">var</span> user, repo, follower;
    <span class="pl-s">var</span> $ <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>jquery<span class="pl-pds">'</span></span>);
  beforeEach(<span class="pl-st">function</span>(){
        <span class="pl-s">var</span> Repo <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>../repo<span class="pl-pds">'</span></span>);
        <span class="pl-s">var</span> User <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>../user<span class="pl-pds">'</span></span>);
        follower <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>../follower<span class="pl-pds">'</span></span>);
        user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>(<span class="pl-s1"><span class="pl-pds">'</span>jcouyang<span class="pl-pds">'</span></span>);
    repo <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Repo</span>(<span class="pl-s1"><span class="pl-pds">'</span>jcouyang<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>gira<span class="pl-pds">'</span></span>);
    <span class="pl-c">// 我们不关心 user, 但是我们希望他能返回一个 deferred 类型</span>
      user.fetch.mockReturnValue($.Deferred().resolve(<span class="pl-s1"><span class="pl-pds">'</span>dont care<span class="pl-pds">'</span></span>));
    <span class="pl-c">// 我们让我们不关心的 user 和 repo 返回我们期望的东西就好</span>
        user.<span class="pl-sc">name</span> <span class="pl-k">=</span><span class="pl-s1"><span class="pl-pds">'</span>jcouyang<span class="pl-pds">'</span></span>;
        user.followers <span class="pl-k">=</span> <span class="pl-c1">20</span>;
        repo.<span class="pl-sc">name</span> <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">'</span>gira<span class="pl-pds">'</span></span>;
        repo.followers <span class="pl-k">=</span> <span class="pl-c1">21</span>;
    <span class="pl-c">// 期待页面上有一个  id 为 content 的元素</span>
        <span class="pl-s3">document</span>.<span class="pl-sc">body</span>.innerHTML <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">'</span>&lt;div id="content"&gt;&lt;/div&gt;<span class="pl-pds">'</span></span>;
    });

  it(<span class="pl-s1"><span class="pl-pds">'</span>should populate properties with data from github api<span class="pl-pds">'</span></span>, <span class="pl-st">function</span>(){
        follower(user,repo);
    <span class="pl-c">// 希望 content 上能得到想要的内容</span>
        expect($(<span class="pl-s1"><span class="pl-pds">"</span>#content<span class="pl-pds">"</span></span>).<span class="pl-sc">text</span>()).toBe(<span class="pl-s1"><span class="pl-pds">'</span>jcouyang<span class="pl-cce">\'</span>s followers: 20 and his repo gira<span class="pl-cce">\'</span>s followers:21<span class="pl-pds">'</span></span>);
  });
});
</pre></div>

<h2>
<a name="user-content-3-manual-mock" class="anchor" href="#3-manual-mock" rel="noreferrer"><span class="octicon octicon-link"></span></a>3. Manual Mock</h2>

<p>好了, 说好的解释 <code>setAjaxReturn</code>是怎么回事的</p>

<p>嗯嗯, 是这样的, 虽然 jest 自动 mock 了我们不关心的模块, 但是我们还是会希望
这个 mock 的玩意能有一些我们期望的行为, 也就是按我们的期望返回一些东西. 比如
这里就是我们不关心 ajax 的逻辑, 但是我们需要他能给我们返回一个东西,并且可以
thenable. 所以单纯的 mock 对象或函数都不能做到, 所以有了 manual mock 这种东西.</p>

<p>用 manual mock 需要建一个<code>__ mocks__</code> 文件夹,然后把所有的 mock 都扔进去. 比如
我想 mock jquery, 那么我建一个<code>jquery.js</code> 扔进去</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> data <span class="pl-k">=</span> {};
<span class="pl-s">var</span> <span class="pl-en">mockDefered</span> <span class="pl-k">=</span> <span class="pl-st">function</span>(<span class="pl-vpf">data</span>){
    <span class="pl-k">return</span> {
        <span class="pl-en">then</span>: <span class="pl-st">function</span>(<span class="pl-vpf">cb</span>){
            <span class="pl-k">return</span> mockDefered(cb(data));
        }
    };
};

<span class="pl-st">function</span> <span class="pl-en">ajax</span>() {
  <span class="pl-k">return</span> mockDefered(data);
}

<span class="pl-st">function</span> <span class="pl-en">setAjaxReturn</span>(<span class="pl-vpf">shouldbe</span>){
    data <span class="pl-k">=</span> shouldbe;
}
<span class="pl-sv">exports</span>.setAjaxReturn <span class="pl-k">=</span> setAjaxReturn;
<span class="pl-sv">exports</span>.ajax <span class="pl-k">=</span> ajax;
</pre></div>

<p>终于看见<code>setAjaxReturn</code>在哪里定义了<img align="absmiddle" alt=":sweat_smile:" class="emoji" height="20" src="https://gist-assets.github.com/assets/emoji/unicode/1f605-1776547fd68545817d4ee4169ed73cc4.png" title=":sweat_smile:" width="20"> 这里暴露两个函数</p>

<ul class="task-list">
<li>setAjaxReturn: 可以设置我希望 ajax 返回的值</li>
<li>ajax: 单纯的返回这个 thenable.</li>
</ul>

<p>所以我也不需要显示的声明 mock jquery什么什么的, 直接在测试里设置ajax 的返回值就好了.</p>

<div class="highlight highlight-js"><pre><span class="pl-s">var</span> $ <span class="pl-k">=</span> <span class="pl-s3">require</span>(<span class="pl-s1"><span class="pl-pds">'</span>jquery<span class="pl-pds">'</span></span>).setAjaxReturn({stargazers_count<span class="pl-k">:</span> <span class="pl-c1">23</span>});</pre></div>

<p>这是 repo 里面 require 的 jquery 已经被 mock 并且只要掉 ajax 都会返回我
期望的值.</p>

<h2>
<a name="user-content-etc" class="anchor" href="#etc" rel="noreferrer"><span class="octicon octicon-link"></span></a>etc</h2>

<ul class="task-list">
<li>
<strong>并行测试</strong>:
还用说么, 既然已经如此模块化好了, user repo 以及 follower 的测试完全是互不依赖.
没有什么理由一个一个测. 因此3个测试的耗时取决于最长时间的那个. 所以如果有
那个测试特别耗时,说明模块还不够细, 多拆几个就快了.</li>
<li>
<strong>promise</strong>: 使用 pit() 来测试 thenable 的对象, 比如 repo 的例子,就 keyi
写成</li>
</ul>

<div class="highlight highlight-javascript"><pre>pit(<span class="pl-s1"><span class="pl-pds">'</span>should populate properties with data from github api<span class="pl-pds">'</span></span>, <span class="pl-st">function</span>(){
  <span class="pl-k">return</span> repo.fetch().then(
    expect(repo.followers).toBe(<span class="pl-c1">23</span>);
  );
});</pre></div>

<ul class="task-list">
<li>
<strong>Timer mocks</strong>: 可以使用 mock 的 timer 和 ticks, 也就是你可以加速
所有的setTimeout, setInterval, clearTimeout, clearInterval行为. 不需要等待.</li>
</ul>

<div class="highlight highlight-js"><pre><span class="pl-s3">setTimeout</span>(<span class="pl-st">function</span>() { callback(); }, <span class="pl-c1">1000</span>);
 expect(callback).not.toBeCalled();
 jest.runAllTimers();
expect(callback).toBeCalled()</pre></div>

<hr>

<h2>
<a name="user-content-wrapup" class="anchor" href="#wrapup" rel="noreferrer"><span class="octicon octicon-link"></span></a>Wrapup</h2>

<p>所以说白了, jest 其实也是个概念, 推荐使用模块化的思想, 这样我只需要保证每个接口的 IO 正确, 就可以保证整个程序没问题. 这样划分下来测试就会变得简单到只需要关心当然模块的 IO 从而
可以 mock 掉所有其他依赖. 真正模块化好的代码单纯的只用 jasmine 或者 mocha
都应该是很好测的. 只是在这个概念之上省去了很多不必要的 mock 代码, 因为要 mock 的
依赖总是占大多数的, 而关心的, 往往只是那么一两个.</p>

<p><a href="https://camo.githubusercontent.com/3e64dbaa084ae3840bbef387c170dbdbee7d9b33/68747470733a2f2f67612d626561636f6e2e61707073706f742e636f6d2f55412d33323331343135342d352f626c6f676973742f332d726561736f6e2d746f2d7573652d6a657374" target="_blank" rel="noreferrer"><img src="https://camo.githubusercontent.com/3e64dbaa084ae3840bbef387c170dbdbee7d9b33/68747470733a2f2f67612d626561636f6e2e61707073706f742e636f6d2f55412d33323331343135342d352f626c6f676973742f332d726561736f6e2d746f2d7573652d6a657374" alt="Analytics" data-canonical-src="https://ga-beacon.appspot.com/UA-32314154-5/blogist/3-reason-to-use-jest" style="max-width:100%;"></a></p>

      </article>
    </div>



          </div>
          <div class="gist-meta">
            <a href="https://gist.github.com/jcouyang/34686f695cd28309759e/raw/3-reason-to-use-jest-to-test-your-javascript.md" style="float:right">view raw</a>
            <a href="https://gist.github.com/jcouyang/34686f695cd28309759e#file-3-reason-to-use-jest-to-test-your-javascript-md">3-reason-to-use-jest-to-test-your-javascript.md</a>
            hosted with &#10084; by <a href="https://github.com">GitHub</a>
          </div>
        </div>
</div>

					</div>
				</div>
				<div class="sidebar col-md-2">
				</div>
			</div>	
		</div>

		<footer>
      <div class="container">
				<div class="row">
					<div class="col-md-2">
					</div>

					<div class="col-md-8">
 						<p>Copyright © Jichao Ouyang</p>
						<p> Powered by <a rel="nofollow" href="http://blogist.github.io">Blogist</a> <span class="glyphicon glyphicon-heart"></span> <a href="http://github.com/jcouyang/kokaku">Kokaku</a> and <a href="https://gist.github.com">Gist</a> </p>
					</div>
				</div>
        <div class="col-md-2">
				</div>


      </div>

    </footer>
	</body>
</html>
